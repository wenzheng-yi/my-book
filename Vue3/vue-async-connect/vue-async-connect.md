### Vue3中不一样的Model、Drawer使用方式

传统的Modal、Drawer使用方式，都是先在父组件中import，然后通过props传visible变量，或者通过ref去调用子组件的方法。当遇到多层级的Model/Drawer，或者同一个组件在多个地方都有引用时，重复的 ”import->调用“ 会显得麻烦。

所以，对于常用的组件，比如Dialog、Message，我们通常会提供 Javascript 的动态渲染方法。

笔者了解到的动态渲染方法有两种，一种是调用时在document上新建一个div标签，然后渲染到那个标签上，类似于element plus；另一种是在顶层包裹一个组件provider，然后把触发方法抽取出来给子组件使用，类似于naive ui。具体实现可查阅各组件库的源码。

但我不想将这种动态渲染方法止步在特定组件上，我想把任意一个Modal、Drawer组件（以下统称为组件）通过简单的设置就能实现动态渲染、而且是以懒加载的形式。于是乎，便写了这个~~玩具~~工具，话不多说，看demo。



从demo中可以看到，我们只需要组件名称就可以调用任意组件，而且只有调用时才会去请求加载文件。

当然，单纯的简单调用，是不能满足开发需求的，所以，它支持向子组件内的方法传参，也支持props传参，以及绑定事件监听。

作为一个全局的工具，无限制地调用不同组件，可能会引起性能问题？所以，工具支持设置最大组件数量，当超过了这个数量时，会将已关闭的组件销毁掉。



当然，这个玩具也有缺陷。比如：开发模式下更改代码，热更新后再次点击请求异步组件就不行，必须得刷新下； 部分组件库的Modal组件会从点击位置弹出来，但如果是首次请求Modal组件，它只会从页面中心弹出来，之后才从点击位置弹出。

如果你仍然对这个工具感兴趣，可以在github中查看更详细的安装方法、api等。



接下来聊聊这个工具的诞生历程。

故事的开始也是因为业务需求。在后台管理系统中，会存在很多同质化的列表页面，页面头部及列表操作栏又会有很多按钮，他们的点击效果大多是打开一个组件，更细致复杂的业务逻辑与交互则集中在组件当中。所以，我们的想法是把列表页面封装成一个渲染器，通过一系列的数据去渲染列表和按钮，而按钮的点击效果，能不能写一个通用的方法，只传递一个特定字符串，类似于key/id，就完成组件调用呢？

刚着手这个功能时，产生过很多idea......

比如，能不能在初始化的时候就把组件注册进来，然后也是通过简单的js调用即可。但随着项目的增长，组件越来越多，肯定消耗不起。所以，得出了第一个功能点，它得是异步懒加载的。而vue刚好有这么一个api，`defineAsyncComponet`，这也是整个工具的核心。

接下来的问题是，如何确定我输入的名称name就是相应地去import某个组件呢？因此，需要建立一个查询，也就是createAsyncConnect时传入的components对象，而这个对象也解决了打包时如何把那些异步组件一同编译的问题。

```javascript
const { connect, AsyncConnectRender } = createAsyncConnect({
    // components 对象是用于查询的
    components: {
        yourName: () => import(/**your component path**/)
    }
})
```



由此，我们已经解决了基本的“传递名称 -> 异步懒加载”。

下一个问题是，懒加载过来了，但是怎么调用组件内部的方法，去打开这个组件呢？刚开始的想法是在调用组件之后，就把组件的ref返回出去，又或者把组件实例返回出去。因为获取到了ref就拥有了极大的控制权，但实现起来都不太理想。而且这里存在异步问题，必须在请求到了之后，才能把实例或ref返回出去。

从设计的角度看，把组件的调用方法放到父组件/请求方，我觉得也是不合理的。因为请求方是可以一对多的，如果把子组件的调用放到父组件，通过ref去触发，那是不是得固定死所有子组件的调用方法名称呢？如果我改动了那个方法名称，是不是子组件和父组件都需改动？这岂不是一种耦合。

所以呢，基于上述两点，我决定把调用方法放到子组件内。怎么做呢？

第一，我们异步请求组件的时候，肯定是希望他能立即打开的；第二，setup是vue3中最早的生命周期。于是，我在子组件的setup中定义了一个异步接收。

```vue
<script lang="ts" setup>
import { onMounted, reactive, ref } from 'vue'
import { connect } from '@/plugin/asyncConnect'
    
const isShow = ref(false)
function open() {
  isShow.value = true
}
connect.receive({
  name: 'yourName', // 定义的组件名称
  flag: isShow,  // 当前组件是否已打开的标识
  trigger: open  // 打开组件的方法
})
</script>
```

当请求到组件时，connect.receive会立即执行，工具内部会调用vue3的onMounted钩子，在钩子内执行open方法。至此，我们已经完成了 “传递名称 -> 异步懒加载 -> 打开组件“ 这个流程，接下来，就剩下传参啦。

传参有2种，第一种是消费型的参数，我们会传递给trigger函数，这种就是在工具内部做了个参数传递；另一种是持久型的参数，我们会把它设置为props，这种是通过vue3的h函数实现的，h函数本身就能接收props，所以我们也是只做了个参数传递。

但这里的问题在于，组件调用过程是异步的，如果我同时调用多个不同的组件，他们的调用时间可能不尽相同，我们如何一一对应上，保证正确的参数给到了正确的组件呢。在80-90年代的电视剧中，特工碰面往往都通过一个暗号，所以，我们也需要一个类似于暗号的标识，而它就是name字段，它在父组件调用、子组件接收时必须是一致的，否则就会error。

##### 未来的计划?

现在的工具是通过ts编写的，我们在call和receive时的时候会得到组件名称的类型提示。但如果是通过批量定义在注册组件，就需要自己编写组件名称的类型参数。这在使用体验上有些不适，所以，后续会尝试自动生成类型文件。
